<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Screenrada ‚Äî Scroll-Stop Camera</title>
  <style>
    body{margin:0;background:#0b0b0c;color:#fff;font-family:-apple-system,system-ui,sans-serif;display:flex;flex-direction:column;align-items:center;gap:1rem;padding:1rem}
    video{width:90vw;max-width:900px;border-radius:10px;background:#000}
    #status{font-size:14px;opacity:.9}
  </style>
</head>
<body>
  <h2>üì∑ Screenrada ‚Äî Scroll-Stop Camera</h2>
  <video id="cam" autoplay playsinline muted></video>
  <canvas id="frame" style="display:none"></canvas>
  <div id="status">Initializing camera‚Ä¶</div>

  <script>
    const v = document.getElementById('cam');
    const f = document.getElementById('frame');
    const ctx = f.getContext('2d', { willReadFrequently: true });
    const statusEl = document.getElementById('status');

    const GRID = 8;
    const MOTION_STOP_DELTA = 0.10;
    const STABLE_FRAMES = 4;
    const COOL_DOWN_MS = 2000;
    const RETAKE_DELAY_MS = 5000;
    const RETAKE_DIFF = 0.20;

    let lastHash = '';
    let stableCount = 0;
    let busy = false;
    let lastShotAt = 0;
    let hashAtShot = null;
    let retakeTimer = null;

    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            focusMode: 'continuous' // may not be honored
          },
          audio: false
        });
        v.srcObject = stream;
        v.onloadedmetadata = () => {
          v.play().catch(e => console.error('Video play error:', e));
          f.width = v.videoWidth;
          f.height = v.videoHeight;
          status('‚úÖ Camera ready. Watching for scroll stop...');
          loop();
        };
      } catch(e){
        status('‚ùå Camera error: '+e.message);
      }
    }

    function drawFullFrame(){
      const vw = v.videoWidth || f.width;
      const vh = v.videoHeight || f.height;
      if (f.width !== vw || f.height !== vh) { f.width = vw; f.height = vh; }
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(v, 0, 0, vw, vh);
    }

    function getHash(){
      const w=f.width, h=f.height;
      const cw = Math.floor(w/GRID), ch = Math.floor(h/GRID);
      const img = ctx.getImageData(0,0,w,h).data;
      let out = '';
      for(let gy=0; gy<GRID; gy++){
        for(let gx=0; gx<GRID; gx++){
          let sum=0, cnt=0, sy=gy*ch, sx=gx*cw;
          for(let y=sy; y<sy+ch && y<h; y++){
            for(let x=sx; x<sx+cw && x<w; x++){
              const i=(y*w+x)*4;
              sum += (img[i]+img[i+1]+img[i+2])/3;
              cnt++;
            }
          }
          out += Math.floor((sum/cnt)/32);
        }
      }
      return out;
    }

    function diffHash(a,b){
      if(!a || !b || a.length!==b.length) return 1;
      let d=0; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) d++;
      return d/a.length;
    }

    function varianceOfLaplacian(){
      const imgData = ctx.getImageData(0, 0, f.width, f.height);
      const gray = [];
      for (let i = 0; i < imgData.data.length; i += 4) {
        const avg = (imgData.data[i] + imgData.data[i+1] + imgData.data[i+2]) / 3;
        gray.push(avg);
      }
      let sum = 0, sumSq = 0;
      for (let i = 0; i < gray.length; i++) {
        sum += gray[i];
        sumSq += gray[i] * gray[i];
      }
      const mean = sum / gray.length;
      const variance = (sumSq / gray.length) - (mean * mean);
      return variance;
    }

    function loop(){
      drawFullFrame();
      const h = getHash();
      const d = diffHash(h, lastHash);

      if (!busy && d <= MOTION_STOP_DELTA) {
        if (++stableCount >= STABLE_FRAMES) {
          maybeShoot(h);
          stableCount = 0;
        }
      } else {
        stableCount = 0;
      }

      lastHash = h;
      requestAnimationFrame(loop);
    }

    function cooldownOver(){ return (Date.now() - lastShotAt) >= COOL_DOWN_MS; }

    function maybeShoot(currentHash){
      if (!cooldownOver()) return;
      const sharpness = varianceOfLaplacian();
      if (sharpness < 150) {
        status('‚ö†Ô∏è Image blurry, retrying focus‚Ä¶');
        setTimeout(() => shoot(currentHash), 200);
      } else {
        shoot(currentHash);
      }
    }

    function shoot(currentHash){
      busy = true;
      lastShotAt = Date.now();
      hashAtShot = currentHash;
      status('üì∏ Capturing‚Ä¶');

      const base64 = f.toDataURL('image/png').split(',')[1];
      fetch('/ask', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ imageBase64: base64 })
      }).then(async (r)=>{
        if(!r.ok) throw new Error('HTTP '+r.status);
        status('‚úÖ Sent. Watching for change (5s)‚Ä¶');
        if (retakeTimer) clearTimeout(retakeTimer);
        retakeTimer = setTimeout(checkForRetake, RETAKE_DELAY_MS);
      }).catch(e=>{
        status('‚ùå Send error: '+e.message);
      }).finally(()=>{
        busy = false;
      });
    }

    function checkForRetake(){
      drawFullFrame();
      const newHash = getHash();
      const change = diffHash(newHash, hashAtShot || '');
      if (change > RETAKE_DIFF) {
        status(`üîÅ Big change (${Math.round(change*100)}%). Retaking‚Ä¶`);
        if (cooldownOver()) shoot(newHash);
      } else {
        status(`‚èπ No major change (${Math.round(change*100)}%). No retake.`);
      }
      hashAtShot = null;
      retakeTimer = null;
    }

    function status(t){ statusEl.textContent = t; }

    startCamera();
  </script>
</body>
</html>
