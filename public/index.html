<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Video Capture Multi-Question AI</title>
  <style>
    body{margin:0;background:#0b0b0c;color:#fff;font-family:-apple-system,system-ui,sans-serif;display:flex;flex-direction:column;align-items:center;gap:1rem;padding:1rem}
    video{width:90vw;max-width:1200px;border-radius:10px;background:#000}
    #status{font-size:14px;opacity:.9}
    #start{border:1px solid #444;padding:.6rem 1rem;border-radius:9px;cursor:pointer;background:#111}
    #questionSection{display:flex;flex-direction:column;gap:1rem;width:90vw;max-width:1200px;margin-top:1rem}
    .questionInput{background:#1a1a1a;border:1px solid #444;color:#fff;padding:.8rem;border-radius:8px;font-size:14px;width:100%;box-sizing:border-box}
    .questionInput::placeholder{color:#666}
    #addQuestion{background:#2c7be5;border:none;padding:.6rem 1rem;border-radius:8px;cursor:pointer;color:#fff;font-weight:600}
    .questionItem{background:#1a1a1a;padding:1rem;border-radius:8px;display:flex;gap:1rem;align-items:center}
    .removeQuestion{background:#e53e3e;border:none;padding:.4rem .8rem;border-radius:6px;cursor:pointer;color:#fff;font-size:12px}
    #answers{width:90vw;max-width:1200px;margin-top:1rem;background:#1a1a1a;padding:1rem;border-radius:8px;min-height:100px}
    .answerBlock{margin-bottom:1.5rem;padding-bottom:1.5rem;border-bottom:1px solid #333}
    .answerBlock:last-child{border-bottom:none}
    .answerQuestion{color:#2c7be5;font-weight:600;margin-bottom:.5rem}
    .answerText{color:#fff;line-height:1.6}
  </style>
</head>
<body>
  <h2>üìπ Video Capture Multi-Question AI</h2>
  <button id="start">Start Video Capture</button>
  <video id="screen" autoplay playsinline muted></video>
  <canvas id="frame" style="display:none"></canvas>
  <div id="status">Idle.</div>
  
  <div id="questionSection" style="display:none">
    <h3>Questions to Ask AI:</h3>
    <div id="questionList"></div>
    <button id="addQuestion">+ Add Question</button>
  </div>

  <div id="answers" style="display:none">
    <h3>AI Answers:</h3>
    <div id="answerList"></div>
  </div>

  <script>
    // ----- DOM refs -----
    const v = document.getElementById('screen');
    const f = document.getElementById('frame');
    let ctx;
    try {
      ctx = f.getContext('2d', { willReadFrequently: true });
      if (!ctx) throw new Error('2D context null with options');
    } catch {
      ctx = f.getContext('2d');
    }
    const statusEl = document.getElementById('status');
    const startBtn = document.getElementById('start');
    const questionSection = document.getElementById('questionSection');
    const questionList = document.getElementById('questionList');
    const addQuestionBtn = document.getElementById('addQuestion');
    const answersDiv = document.getElementById('answers');
    const answerList = document.getElementById('answerList');

    // ----- Tuning -----
    const GRID = 8;
    const MOTION_STOP_DELTA = 0.10;
    const STABLE_FRAMES = 4;
    const COOL_DOWN_MS = 2000;
    const RETAKE_DELAY_MS = 2000;
    const RETAKE_DIFF = 0.20;
    const SHARP_MIN = 200;

    // ----- State -----
    let lastHash = '';
    let stableCount = 0;
    let busy = false;
    let lastShotAt = 0;
    let hashAtShot = null;
    let retakeTimer = null;
    let stream = null;
    let track = null;
    let questions = [];
    let questionCounter = 0;

    // ----- Question Management -----
    function addQuestion(text = '') {
      const id = ++questionCounter;
      const question = { id, text };
      questions.push(question);
      
      const div = document.createElement('div');
      div.className = 'questionItem';
      div.dataset.id = id;
      div.innerHTML = `
        <input type="text" class="questionInput" placeholder="Enter your question..." value="${text}">
        <button class="removeQuestion">Remove</button>
      `;
      
      const input = div.querySelector('.questionInput');
      input.addEventListener('input', (e) => {
        const q = questions.find(q => q.id === id);
        if (q) q.text = e.target.value;
      });
      
      const removeBtn = div.querySelector('.removeQuestion');
      removeBtn.addEventListener('click', () => {
        questions = questions.filter(q => q.id !== id);
        div.remove();
      });
      
      questionList.appendChild(div);
    }

    addQuestionBtn.onclick = () => addQuestion();

    // Add one default question
    addQuestion('What is shown on the screen?');

    // ----- Video Capture (USB/Webcam Device) -----
    startBtn.onclick = startVideoCapture;

    async function startVideoCapture(){
      try{
        status('üìπ Requesting video capture device access‚Ä¶');
        console.log('Starting video capture process...');
        
        // Check if mediaDevices is available
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('getUserMedia not supported in this browser. Try Chrome or Edge.');
        }
        
        // First, enumerate devices to see what's available
        console.log('Enumerating video devices...');
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        
        console.log('Available video devices:', videoDevices);
        console.log('Total video devices found:', videoDevices.length);
        
        if (videoDevices.length === 0) {
          throw new Error('No video devices found. Make sure your USB capture device is connected.');
        }
        
        // Request the video stream - user will select their capture device
        const constraints = {
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 30 }
          },
          audio: false
        };
        
        console.log('Requesting user media with constraints:', constraints);
        status('üìπ Browser asking for camera permission...');
        
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('Stream obtained:', stream);
        
        track = stream.getVideoTracks()[0];
        console.log('Video track:', track);
        console.log('Track settings:', track.getSettings());
        
        v.srcObject = stream;
        console.log('Video source set');
        
        startBtn.style.display = 'none';
        questionSection.style.display = 'flex';
        answersDiv.style.display = 'block';
        
        status('üìπ Video loading...');
        await v.play().catch((err)=>{
          console.error('Video play error:', err);
        });
        console.log('Video playing');
        
        // Handle user stopping the stream
        track.addEventListener('ended', () => {
          status('üõë Video capture ended. Click "Start Video Capture" to begin again.');
          startBtn.style.display = 'inline-block';
          questionSection.style.display = 'none';
          answersDiv.style.display = 'none';
          cancelRetake();
          busy = false;
        });
        
        status('‚è≥ Waiting for video dimensions...');
        await waitForDims(v);
        console.log('Video dimensions:', v.videoWidth, 'x', v.videoHeight);
        
        setCanvasSizeToVideo();
        console.log('Canvas size set:', f.width, 'x', f.height);
        
        status('‚úÖ Video capture ready. I'll snap when the content stops changing.');
        loop();
      }catch(e){
        status('‚ùå Video capture error: ' + (e.message || e));
        console.error('Full error details:', e);
        console.error('Error name:', e.name);
        console.error('Error message:', e.message);
        
        // Provide specific guidance based on error type
        if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
          status('‚ùå Permission denied. Please allow camera access and reload the page.');
        } else if (e.name === 'NotFoundError' || e.name === 'DevicesNotFoundError') {
          status('‚ùå No camera found. Make sure your USB capture device is connected.');
        } else if (e.name === 'NotReadableError' || e.name === 'TrackStartError') {
          status('‚ùå Camera already in use by another application.');
        } else {
          status('‚ùå Error: ' + e.message);
        }
      }
    }

    function setCanvasSizeToVideo(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const vw = v.videoWidth, vh = v.videoHeight;
      f.width  = Math.floor(vw * dpr);
      f.height = Math.floor(vh * dpr);
    }

    async function waitForDims(videoEl){
      for (let i=0;i<40;i++){
        if (videoEl.videoWidth && videoEl.videoHeight) return;
        await waitMs(50);
      }
    }

    // ----- Draw & hash -----
    function drawFullFrame(){
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(v, 0, 0, f.width, f.height);
    }

    function getHash(){
      const w=f.width, h=f.height;
      const cw = Math.max(1, Math.floor(w/GRID)), ch = Math.max(1, Math.floor(h/GRID));
      const img = ctx.getImageData(0,0,w,h).data;
      let out = '';
      for(let gy=0; gy<GRID; gy++){
        for(let gx=0; gx<GRID; gx++){
          let sum=0, cnt=0, sy=gy*ch, sx=gx*cw;
          for(let y=sy; y<Math.min(sy+ch,h); y++){
            for(let x=sx; x<Math.min(sx+cw,w); x++){
              const i=(y*w+x)*4;
              sum += (img[i]+img[i+1]+img[i+2])/3;
              cnt++;
            }
          }
          out += Math.floor((sum/Math.max(1,cnt))/32);
        }
      }
      return out;
    }

    function diffHash(a,b){
      if(!a || !b || a.length!==b.length) return 1;
      let d=0; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) d++;
      return d/a.length;
    }

    function laplacianVariance(){
      const w = f.width, h = f.height;
      const { data } = ctx.getImageData(0, 0, w, h);
      const gray = new Float32Array(w*h);
      for (let y=0, i=0, j=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4, j++){
          gray[j] = (data[i] + data[i+1] + data[i+2]) / 3;
        }
      }
      let sum=0, sumSq=0, count=0;
      for (let y=1; y<h-1; y++){
        for (let x=1; x<w-1; x++){
          const idx = y*w + x;
          const L = -4*gray[idx] + gray[idx-1] + gray[idx+1] + gray[idx-w] + gray[idx+w];
          sum += L; sumSq += L*L; count++;
        }
      }
      const mean = sum / count;
      return (sumSq / count) - (mean*mean);
    }

    // ----- Core loop -----
    function loop(){
      drawFullFrame();
      const h = getHash();
      const d = diffHash(h, lastHash);
      if (!busy && d <= MOTION_STOP_DELTA) {
        if (++stableCount >= STABLE_FRAMES) {
          maybeShoot(h);
          stableCount = 0;
        }
      } else {
        stableCount = 0;
      }
      lastHash = h;
      requestAnimationFrame(loop);
    }

    // ----- Shooting logic -----
    function cooldownOver(){ return (Date.now() - lastShotAt) >= COOL_DOWN_MS; }

    function maybeShoot(currentHash){
      if (!cooldownOver()) return;
      shoot(currentHash);
    }

    async function shoot(currentHash){
      busy = true;
      lastShotAt = Date.now();
      hashAtShot = currentHash;
      
      try{
        drawFullFrame();
        let sharp = laplacianVariance();
        if (sharp < SHARP_MIN){
          status(`üîé Soft frame (var=${Math.round(sharp)} < ${SHARP_MIN}). Re-draw‚Ä¶`);
          await waitMs(100);
          drawFullFrame();
          sharp = laplacianVariance();
          status(`üîç Sharpness after redraw: var=${Math.round(sharp)}`);
        }else{
          status(`üü¢ Stable & sharp (var=${Math.round(sharp)}). Capturing‚Ä¶`);
        }

        const base64 = f.toDataURL('image/png').split(',')[1];
        
        // Filter out empty questions
        const activeQuestions = questions.filter(q => q.text.trim());
        
        if (activeQuestions.length === 0) {
          status('‚ö†Ô∏è No questions entered. Add at least one question.');
          busy = false;
          return;
        }

        status(`üì§ Sending image with ${activeQuestions.length} question(s) to AI‚Ä¶`);

        // Send image and all questions to AI
        const response = await fetch('/ask', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ 
            imageBase64: base64,
            questions: activeQuestions.map(q => q.text)
          })
        });

        if (response.ok) {
          const data = await response.json();
          displayAnswers(data.answers);
          status('‚úÖ Sent. Watching for ‚â•20% change (2s)‚Ä¶');
        } else {
          status('‚ùå Server error: ' + response.statusText);
        }

        cancelRetake();
        retakeTimer = setTimeout(checkForRetake, RETAKE_DELAY_MS);
      }catch(e){
        status('‚ùå Capture/Send error: ' + e.message);
        console.error(e);
      }finally{
        busy = false;
      }
    }

    function displayAnswers(answers) {
      answerList.innerHTML = '';
      
      if (!answers || answers.length === 0) {
        answerList.innerHTML = '<p style="color:#999">No answers received yet.</p>';
        return;
      }

      answers.forEach((answer, index) => {
        const block = document.createElement('div');
        block.className = 'answerBlock';
        
        const questionDiv = document.createElement('div');
        questionDiv.className = 'answerQuestion';
        questionDiv.textContent = `Q${index + 1}: ${answer.question}`;
        
        const answerDiv = document.createElement('div');
        answerDiv.className = 'answerText';
        answerDiv.textContent = answer.answer;
        
        block.appendChild(questionDiv);
        block.appendChild(answerDiv);
        answerList.appendChild(block);
      });
    }

    function checkForRetake(){
      drawFullFrame();
      const newHash = getHash();
      const change = diffHash(newHash, hashAtShot || '');
      if (change >= RETAKE_DIFF) {
        status(`üîÅ Change ${Math.round(change*100)}% ‚â• 20%. Taking one retake‚Ä¶`);
        if (cooldownOver()) shoot(newHash);
      } else {
        status(`‚èπ Change ${Math.round(change*100)}% < 20%. No retake.`);
      }
      hashAtShot = null;
      cancelRetake();
    }

    function cancelRetake(){
      if (retakeTimer) { clearTimeout(retakeTimer); retakeTimer = null; }
    }

    // ----- Helpers -----
    function status(t){ statusEl.textContent = t; }
    function waitMs(ms){ return new Promise(r=>setTimeout(r, ms)); }
  </script>
</body>
</html>
