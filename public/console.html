<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Console Display</title>
  <style>
    html,body{ height:100%; }
    body{
      margin:0;background:#000;color:#fff;font-family:-apple-system,system-ui,sans-serif;
      display:flex;align-items:center;justify-content:center;
    }
    /* Container that holds text when shown */
    #stage{
      width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;
      gap:14px; background:#000;
    }
    #answer{ font-weight:900; line-height:1.06; text-shadow:0 0 40px rgba(44,123,229,.3); text-align:center; }
    #override{ font-weight:800; line-height:1.06; color:#ffd166; text-align:center; }
    #overrideLabel{ font-size:16px; letter-spacing:.08em; opacity:.9; text-transform:uppercase; text-align:center; }

    .hidden{ display:none !important; }
  </style>
</head>
<body>
  <div id="stage" class="hidden" aria-live="polite">
    <div id="answer"></div>
    <div id="overrideLabel" class="hidden">Override:</div>
    <div id="override" class="hidden"></div>
  </div>

  <script>
    const stage=document.getElementById('stage');
    const answerEl=document.getElementById('answer');
    const overrideEl=document.getElementById('override');
    const overrideLabel=document.getElementById('overrideLabel');

    let currentAnswer=''; let currentOverride=''; let forceBlank=false;

    // Show/hide entire stage (black background is body)
    function applyBlank(){
      const shouldShow = !forceBlank && (currentAnswer || currentOverride);
      stage.classList.toggle('hidden', !shouldShow);
      if(shouldShow) autoFit();
    }

    function setAnswer(text){
      currentAnswer = (text||'').trim();
      answerEl.textContent = currentAnswer;
      applyBlank();
    }
    function setOverride(text){
      currentOverride = (text||'').trim();
      const on = !!currentOverride;
      overrideLabel.classList.toggle('hidden', !on);
      overrideEl.classList.toggle('hidden', !on);
      overrideEl.textContent = currentOverride;
      applyBlank();
    }

    // Auto-fit both lines into viewport nicely
    function autoFit(){
      fitText(answerEl, 140, 24);
      fitText(overrideEl, 80, 18);
    }
    function fitText(el, maxPx, minPx){
      if(!el || el.classList.contains('hidden') || !el.textContent) return;
      let size=maxPx;
      el.style.fontSize=size+'px';
      const vw=window.innerWidth, vh=window.innerHeight;
      for(let i=0;i<60;i++){
        const r=el.getBoundingClientRect();
        if(r.width<=vw*0.92 && r.height<=vh*0.7) break;
        size=Math.max(minPx, size-2);
        el.style.fontSize=size+'px';
        if(size===minPx) break;
      }
    }
    window.addEventListener('resize', autoFit);

    // Extract numbered list from model JSON or text
    function extractNumbered(content){
      if(typeof content==='string'){
        let parsed;
        try{ parsed=JSON.parse(content); }catch{
          const m=content.match(/^\s*```(?:json)?\s*([\s\S]*?)\s*```\s*$/i);
          if(m){ try{ parsed=JSON.parse(m[1]); }catch{} }
        }
        if(parsed?.answers && Array.isArray(parsed.answers)){
          const items=parsed.answers
            .map((a,i)=>({ n:Number.isFinite(+a.number)?+a.number:(i+1), t:(a?.answer??'').toString().trim() }))
            .filter(x=>x.t).sort((a,b)=>a.n-b.n);
          if(items.length) return items.map(x=>`${x.n}. ${x.t}`).join('  ');
        }
        const m2=[...content.matchAll(/^\s*(\d+)\.\s*(.+)$/gm)].map(x=>`${x[1]}. ${x[2].trim()}`);
        if(m2.length) return m2.join('  ');
        return content.trim();
      }
      try{ return JSON.stringify(content); }catch{ return ''; }
    }

    // SSE
    let es;
    function connect(){
      es = new EventSource('/events');

      es.onmessage = (msg) => {
        try{
          const data=JSON.parse(msg.data);

          if(data.type==='log'){
            if(data.event==='sending_to_ai'){
              // Blank the screen while sending/awaiting
              forceBlank = true;
              applyBlank();
            }else if(data.event==='override_set'){
              setOverride(data.meta?.text||'');
            }else if(data.event==='override_clear'){
              setOverride('');
            }
            return;
          }

          if(data.type==='answer'){
            forceBlank = false; // unblank on answer
            const payload=data.payload;
            if(payload?.error){
              setAnswer((payload.error?.message||'').trim());
              return;
            }
            const content=payload?.choices?.[0]?.message?.content;
            if(!content){ setAnswer(''); return; }
            const txt=extractNumbered(content);
            setAnswer(txt);
          }
        }catch(e){
          // On any parse issues, blank
          setAnswer('');
        }
      };

      es.onerror=()=>{ es.close(); setTimeout(connect,3000); };
    }
    connect();
    setInterval(()=>{ if(es && es.readyState===2){ connect(); } },5000);
  </script>
</body>
</html>
